# 专业术语解释

## BSRR 寄存器

### BSRR 寄存器介绍

BSRR 寄存器是一个 32 位的寄存器，用来原子地设置或清除 GPIOA 的 16 个引脚的输出状态。

### BSRR 寄存器高 16 位与低 16 位

- BSRR 寄存器的低 16 位用来设置 GPIO 的输出状态。如果在低 16 位中写入一个 1，那么对应的引脚就会被设置为高电平（1）。如果写入一个 0，那么对应的引脚就不会受到影响。例如，如果写入 0b00000000_00010000，那么第四个引脚就会被设置为高电平（1），而其他引脚保持不变。

- BSRR 寄存器的高 16 位用来清除 GPIO 的输出状态。如果在高 16 位中写入一个 1，那么对应的引脚就会被清除为低电平（0）。如果写入一个 0，那么对应的引脚就不会受到影响。例如，如果写入 0b00010000_00000000_00000000_00000000，那么第二十个引脚就会被清除为低电平（0），而其他引脚保持不变。

### 原生寄存器使用案例

```rust
gpioa.bsrr.write(|w| unsafe { w.bits(1 << (16 + LED_PIN)) });
```

这段代码是使用 stm32f1 库来操作 GPIOA 的 BSRR 寄存器的。BSRR 寄存器是一个 32 位的寄存器，用来原子地设置或清除 GPIOA 的 16 个引脚的输出状态 1。

这段代码的作用是将 GPIOA 的 LED_PIN 引脚（假设为 5）清除为低电平（0）。它的原理是：

- 首先，使用左移运算符（<<）将数字 1 左移 (16 + LED_PIN) 位，得到一个二进制数，其中只有第 (16 + LED_PIN) 位为 1，其余位为 0。例如，如果 LED_PIN 为 5，则得到的二进制数为 0b00100000_00000000_00000000_00000000。
- 然后，使用 write 方法来写入 BSRR 寄存器。write 方法接受一个闭包作为参数，闭包中有一个可变引用 w，指向 BSRR 寄存器的写入代理对象。
  接着，使用 unsafe 块来表明这段代码可能会造成未定义行为，需要谨慎使用。unsafe 块中有一个表达式 w.bits(1 << (16 + LED_PIN))，表示将 w 的 bits 字段设置为 1 << (16 + LED_PIN) 的值。
- 最后，当 write 方法执行时，它会将 w 的 bits 字段的值写入 BSRR 寄存器。由于 BSRR 寄存器的高 16 位用来清除 GPIOA 的输出状态 2，所以这样就相当于将第 LED_PIN 引脚清除为低电平（0），而不影响其他引脚的状态。
  因此，这段代码中的 16 的作用是将数字 1 移动到 BSRR 寄存器的高 16 位中，以便清除对应的引脚。如果不加上 16，那么就会将数字 1 移动到 BSRR 寄存器的低 16 位中，以便设置对应的引脚。

### 友好寄存器使用案例

```rust
// 定义 LED 连接的引脚号（PA1）
const LED_PIN: u16 = 1;

// 设置 PA1 引脚为高电平
// 将 GPIOA 的 LED_PIN 引脚设置为高电平（1）；
// 使用左移运算符（<<）将数字 1 左移 LED_PIN 位，得到一个二进制数，其中只有第 LED_PIN 位为 1，其余位为 0。
// 例如，如果 LED_PIN 为 5，则得到的二进制数为 0b00100000。
gpioa.bsrr.write(|w| unsafe { w.bits(1 << LED_PIN) });
gpioa.bsrr.write(|w| w.bs1().set_bit()); // 高电平
gpioa.bsrr.write(|w| w.bs1().clear_bit()); // 低电平

// 设置 PA1 引脚为低电平
// 由于 BSRR 寄存器的高 16 位用来清除 GPIOA 的输出状态，
// 所以这样就相当于将第 LED_PIN 引脚清除为低电平（0），而不影响其他引脚的状态。
gpioa.bsrr.write(|w| unsafe { w.bits(1 << (16 + LED_PIN)) });
gpioa.bsrr.write(|w| w.br1().set_bit()); // 低电平
gpioa.bsrr.write(|w| w.br1().reset()); // 低电平
gpioa.bsrr.write(|w| w.br1().clear_bit()); // 高电平
```
